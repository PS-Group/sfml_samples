## Искуственные ограничения для C++

Статья предназначена для студентов 2 курса в Институте ПС и ПГТУ, а также для всех новичков в C++. Перечислены механизмы, которые изучаются на предмете ООП в 4-м семестре, но не рекомендуются к использованию до начала предмета ООП (Объектно-Ориентированное Программирование).

### Причины ограничения
- некоторые "простые" средства C++ таят в себе сложную механику
- сложная механика создана для разработчиков библиотек, исследователей или просто более опытных программистов
- качественные статьи в Интернете обычно не указывают минимальный уровень, требуемый для понимания кода
- некачественные статьи и вовсе предлагают некорректный, плохо написанный код
- язык C++ развивается с 1985-го года и многие вещи _теперь_ делаются проще, чем в старых статьях

### Не используйте принцип Google-and-Paste
- код в интернете часто написан небрежно, некачественно или не для Вас
- неразборчивость в сочетании с неопытностью приведёт к тому, что называют "отстрелить себе ногу"
- копируя код, приводите его стиль к [общим соглашениям](../coding-style/cpp-style-sfml.md)
- проверьте также лаконичность и современность взятого кода, исправьте недостатки
- проверьте корректность кода в условиях решаемой задачи, исправьте проблемы
- обратите внимание на лицензию и на правовые вопросы
- после этих шагов вы можете больше не называть код "чужим"

### Не выбрасывайте исключения
Нельзя использовать
- ключевое слово throw
- функцию std::rethrow_exception
Альтернатипы
- кодирование ошибки в значении, возвращаемом функцией. Пример: [fopen](http://en.cppreference.com/w/c/io/fopen)
- сохранение информации об ошибке в параметрах функции. Пример: ```bool loadTiledMap(std::string const& path, std::string &error)```
- [short-circuit evaluation](https://en.wikipedia.org/wiki/Short-circuit_evaluation):
```cpp
int a = 0;
if (a != 0 && myfunc(b))
{
    do_something();
}
```
Если бросаете исключения, будьте готовы рассказать преподавателю о
- сохранении и перевыбросе исключения
- передаче исключения в другой поток
- механизме stack unwinding и стеке программы
- условиях появления std::bad_alloc
- взаимодействии деструкторов с исключениями, идиоме RAII

### Будьте аккуратны с ООП и паттернами
ООП &mdash; хороший способ держать код под контролем. Также есть задачи, где ООП подходит идеально: например, разработка компонентов для оконного графического интерфейса. Фреймворк SFML построен на ООП, но в собственном коде ООП следует применять аккуратно
- пишите ```struct``` вместо ```class```, либо будьте готовы рассказать всё про инкапсуляцию
- не используйте ```virtual``` без ```override``` и виртуальных деструкторов
- не используйте конструкторы, если не знаете о приниципах наследования, списках инициализации конструктора и ```explicit```
Альтернативы:
- прямой альтернативой virtual являются указатели на функцию и ```std::function```: [статья](http://probablydance.com/2012/12/16/the-importance-of-stdfunction/)

### Не пишите шаблонные классы
- не пишите шаблонные структуры и классы
- избегайте статей в Интернете, предлагающих metaprogramming и compile-time в C++
- шаблонные функции вполне просты и допустимы
- можно использовать шаблонные классы STL, такие как ```std::string``` и ```std::vector```
Хорошие шаблоны из STL:
- шаблонные функции из &lt;algorithm&gt;: ```std::max, std::any_of, std::count, std::remove_if```
- шаблонные классы из STL: ```std::string, std::vector, std::map, std::set, std::array, std::unordered_map```

### Избегайте многопоточных вычислений
- доказать корректность многопоточной программы гораздо сложнее
- избегайте создавать новые потоки ОС
- проблемы с производительностью в 2D-играх студентов потоками не решаются
Для оптимизации кода:
- используйте профилирование
- избегайте излишних операций выделения памяти в куче, в том числе неявных
- частая причина низкой скорости: постоянное пересоздание ```std::string``` или ```std::vector```, ведущее к неявному выделению памяти

### Читать далее
- [сатирический пример переусложнённого кода на Java с ООП](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition)
